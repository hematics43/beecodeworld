<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Travel in time, just move</title>
<style>
  body {
    margin: 0;
    background: #05060a;
    color: #fff;
    font-family: sans-serif;
    overflow: hidden;
    touch-action: none; /* stop scroll during drag */
  }
  canvas {
    display: block;
    width: 100vw;
    height: 100vh;
    background: radial-gradient(circle at center, #0a0c16, #05060a);
  }
  #speedControl {
    position: absolute;
    bottom: 15px;
    left: 50%;
    transform: translateX(-50%);
    width: 100%;
  }
  #speedLabel {
    position: absolute;
    bottom: 45px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 200%;
    color: #ccc;
  }

  /* heading styles */
  :root { --accent1:#56d4ff; --accent2:#7b6cff; --text:#e8eef8; }
  .heading-wrap { text-align:center; padding:20px; position:absolute; top:10px; left:50%; transform:translateX(-50%); }
  .super-title { font-size:clamp(22px,5vw,40px); font-weight:800; color:var(--text); margin:0; position:relative; }
  .super-title::after {
    content:""; position:absolute; bottom:-10px; left:50%; transform:translateX(-50%);
    width:60%; height:5px; border-radius:999px;
    background:linear-gradient(90deg,var(--accent1),var(--accent2));
    animation:pulse 2.6s infinite;
  }
  @keyframes pulse {
    0%{transform:translateX(-50%) scaleX(.9);opacity:.7}
    50%{transform:translateX(-50%) scaleX(1.1);opacity:1}
    100%{transform:translateX(-50%) scaleX(.9);opacity:.7}
  }
</style>
</head>
<body>
  <div class="heading-wrap">
    <h1 class="super-title">Travel in time, just move</h1>
    
      <div class="subtitle">When you move fast, time will slow. <h5>~Albert Einstein</h5></div>
    <div>Double Tap | Drag Nodes | Control Speed</div>
  </div> 

<canvas id="flow"></canvas>
<label id="speedLabel">âš¡ Speed</label>
<input type="range" min="1" max="500" value="80" id="speedControl">

<script>
const canvas = document.getElementById("flow");
const ctx = canvas.getContext("2d");
resize();
window.addEventListener("resize", resize);

function resize(){ canvas.width=innerWidth; canvas.height=innerHeight; }

// --- Data ---
let nodes=[], edges=[];
let dragging=null, hoverNode=null;
let flowSpeed=0.008*8;
const colors=["#00ffe0","#ff6b9f","#56d4ff","#7b6cff","#f5d742","#ff914d"];

function resetNodes(){
  nodes=[{x:100,y:200,w:100,h:50,label:"Unit",color:colors[0]}];
  autoConnect();
}
resetNodes();

function autoConnect(){
  edges=[];
  for(let i=0;i<nodes.length-1;i++){
    edges.push({from:nodes[i],to:nodes[i+1]});
  }
}

// Particles
let particles=Array.from({length:60},()=>({pos:Math.random(),edgeIndex:0}));

// Helpers
function findNode(x,y){
  return nodes.find(n=>x>n.x&&x<n.x+n.w&&y>n.y&&y<n.y+n.h);
}
function deleteNode(node){ nodes=nodes.filter(n=>n!==node); autoConnect(); }
function addNode(x,y){
  let idx=nodes.length;
  nodes.push({x:x-60,y:y-25,w:120,h:50,label:"Unit"+idx,color:colors[idx%colors.length]});
  autoConnect();
}

// Mouse drag
canvas.addEventListener("mousedown",e=>{
  const mx=e.offsetX,my=e.offsetY;
  const n=findNode(mx,my);
  if(n){ dragging=n; dragging.dx=mx-n.x; dragging.dy=my-n.y; }
});
canvas.addEventListener("mousemove",e=>{
  const mx=e.offsetX,my=e.offsetY;
  hoverNode=findNode(mx,my);
  if(dragging){ dragging.x=mx-dragging.dx; dragging.y=my-dragging.dy; }
});
canvas.addEventListener("mouseup",()=>dragging=null);

// Touch drag
canvas.addEventListener("touchstart",e=>{
  const t=e.touches[0],mx=t.clientX,my=t.clientY;
  const n=findNode(mx,my);
  if(n){ dragging=n; dragging.dx=mx-n.x; dragging.dy=my-n.y; }
});
canvas.addEventListener("touchmove",e=>{
  const t=e.touches[0],mx=t.clientX,my=t.clientY;
  hoverNode=findNode(mx,my);
  if(dragging){ dragging.x=mx-dragging.dx; dragging.y=my-dragging.dy; }
});
canvas.addEventListener("touchend",()=>dragging=null);

// Double click add/delete (desktop)
canvas.addEventListener("dblclick",e=>{
  const n=findNode(e.offsetX,e.offsetY);
  if(n) deleteNode(n); else addNode(e.offsetX,e.offsetY);
});

// Double tap add/delete (mobile)
let lastTap=0,lastX=0,lastY=0;
canvas.addEventListener("touchend",e=>{
  const t=e.changedTouches[0],now=Date.now();
  const x=t.clientX,y=t.clientY;
  if(now-lastTap<300 && Math.abs(x-lastX)<30 && Math.abs(y-lastY)<30){
    const n=findNode(x,y);
    if(n) deleteNode(n); else addNode(x,y);
  }
  lastTap=now; lastX=x; lastY=y;
});

// Speed control
document.getElementById("speedControl").addEventListener("input",e=>{
  flowSpeed=0.001*e.target.value;
});

// --- Drawing loop ---
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // edges
  ctx.lineWidth=2.5;
  for(let e of edges){
    const ax=e.from.x+e.from.w/2,ay=e.from.y+e.from.h/2;
    const bx=e.to.x+e.to.w/2,by=e.to.y+e.to.h/2;
    const grad=ctx.createLinearGradient(ax,ay,bx,by);
    grad.addColorStop(0,e.from.color); grad.addColorStop(1,e.to.color);
    ctx.strokeStyle=grad; ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();
  }

  // particles
  for(let p of particles){
    const e=edges[p.edgeIndex]; if(!e) continue;
    const ax=e.from.x+e.from.w/2,ay=e.from.y+e.from.h/2;
    const bx=e.to.x+e.to.w/2,by=e.to.y+e.to.h/2;
    const x=ax+(bx-ax)*p.pos,y=ay+(by-ay)*p.pos;
    ctx.beginPath(); ctx.fillStyle="#fff"; ctx.shadowColor="#fff"; ctx.shadowBlur=12;
    ctx.arc(x,y,4,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0;
    p.pos+=flowSpeed; if(p.pos>1){p.pos=0;p.edgeIndex=Math.floor(Math.random()*edges.length);}
  }

  // nodes
  for(let n of nodes){
    ctx.fillStyle="rgba(255,255,255,0.07)";
    ctx.strokeStyle=n.color;
    ctx.lineWidth=(n===hoverNode?4:2);
    ctx.beginPath();
    ctx.roundRect(n.x,n.y,n.w,n.h,12);
    ctx.fill(); ctx.stroke();
    ctx.fillStyle="#fff"; ctx.font="14px sans-serif"; ctx.textAlign="center";
    ctx.fillText(n.label,n.x+n.w/2,n.y+n.h/2+5);
  }

  requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>
